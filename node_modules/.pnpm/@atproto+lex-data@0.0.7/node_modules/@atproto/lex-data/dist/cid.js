"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CID = exports.SHA256_MULTIHASH = exports.RAW_MULTICODEC = exports.DAG_CBOR_MULTICODEC = void 0;
exports.isRawCid = isRawCid;
exports.isDaslCid = isDaslCid;
exports.isCborCid = isCborCid;
exports.ifCid = ifCid;
exports.isCid = isCid;
exports.asCid = asCid;
exports.parseCid = parseCid;
exports.decodeCid = decodeCid;
exports.validateCidString = validateCidString;
exports.parseCidString = parseCidString;
exports.ensureValidCidString = ensureValidCidString;
exports.isCidForBytes = isCidForBytes;
exports.cidForCbor = cidForCbor;
exports.cidForRawBytes = cidForRawBytes;
exports.cidForRawHash = cidForRawHash;
const cid_1 = require("multiformats/cid");
Object.defineProperty(exports, "CID", { enumerable: true, get: function () { return cid_1.CID; } });
const digest_1 = require("multiformats/hashes/digest");
const sha2_1 = require("multiformats/hashes/sha2");
exports.DAG_CBOR_MULTICODEC = 0x71; // DRISL conformant DAG-CBOR
exports.RAW_MULTICODEC = 0x55; // raw binary codec used in DASL CIDs
exports.SHA256_MULTIHASH = sha2_1.sha256.code;
function isRawCid(cid) {
    return cid.version === 1 && cid.code === exports.RAW_MULTICODEC;
}
function isDaslCid(cid) {
    return (cid.version === 1 &&
        (cid.code === exports.RAW_MULTICODEC || cid.code === exports.DAG_CBOR_MULTICODEC) &&
        cid.multihash.code === exports.SHA256_MULTIHASH &&
        cid.multihash.size === 32 // Should always be 32 bytes (256 bits) for SHA-256
    );
}
function isCborCid(cid) {
    return cid.code === exports.DAG_CBOR_MULTICODEC && isDaslCid(cid);
}
function ifCid(value, options) {
    const cid = cid_1.CID.asCID(value);
    if (!cid) {
        return null;
    }
    switch (options?.flavor) {
        case 'cbor':
            return isCborCid(cid) ? cid : null;
        case 'raw':
            return isRawCid(cid) ? cid : null;
        case 'dasl':
            return isDaslCid(cid) ? cid : null;
        default:
            return cid;
    }
}
function isCid(value, options) {
    return ifCid(value, options) !== null;
}
function asCid(value, options) {
    const cid = ifCid(value, options);
    if (cid)
        return cid;
    throw new Error('Not a valid CID');
}
function parseCid(input, options) {
    const cid = cid_1.CID.parse(input);
    return asCid(cid, options);
}
function decodeCid(cidBytes, options) {
    const cid = cid_1.CID.decode(cidBytes);
    return asCid(cid, options);
}
function validateCidString(input, options) {
    return parseCidString(input, options)?.toString() === input;
}
function parseCidString(input, options) {
    try {
        return parseCid(input, options);
    }
    catch {
        return undefined;
    }
}
function ensureValidCidString(input, options) {
    if (!validateCidString(input, options)) {
        throw new Error(`Invalid CID string`);
    }
}
/**
 * Verifies whether the multihash of a given {@link cid} matches the hash of the provided {@link bytes}.
 * @params cid The CID to match against the bytes.
 * @params bytes The bytes to verify.
 * @returns true if the CID matches the bytes, false otherwise.
 */
async function isCidForBytes(cid, bytes) {
    if (cid.multihash.code === sha2_1.sha256.code) {
        const digest = await sha2_1.sha256.digest(bytes);
        return (0, digest_1.equals)(cid.multihash, digest);
    }
    if (cid.multihash.code === sha2_1.sha512.code) {
        const digest = await sha2_1.sha512.digest(bytes);
        return (0, digest_1.equals)(cid.multihash, digest);
    }
    // Don't know how to verify other multihash codes
    throw new Error('Unsupported CID multihash');
}
async function cidForCbor(bytes) {
    const digest = await sha2_1.sha256.digest(bytes);
    return cid_1.CID.createV1(exports.DAG_CBOR_MULTICODEC, digest);
}
async function cidForRawBytes(bytes) {
    const digest = await sha2_1.sha256.digest(bytes);
    return cid_1.CID.createV1(exports.RAW_MULTICODEC, digest);
}
function cidForRawHash(hash) {
    // Fool-proofing
    if (hash.length !== 32) {
        throw new Error(`Invalid SHA-256 hash length: ${hash.length}`);
    }
    const digest = (0, digest_1.create)(sha2_1.sha256.code, hash);
    return cid_1.CID.createV1(exports.RAW_MULTICODEC, digest);
}
//# sourceMappingURL=cid.js.map