{"version":3,"file":"cid.js","sourceRoot":"","sources":["../src/cid.ts"],"names":[],"mappings":"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","sourcesContent":["import { CID } from 'multiformats/cid'\nimport {\n  create as createDigest,\n  equals as digestEquals,\n} from 'multiformats/hashes/digest'\nimport { sha256, sha512 } from 'multiformats/hashes/sha2'\n\nexport const DAG_CBOR_MULTICODEC = 0x71 // DRISL conformant DAG-CBOR\nexport type DAG_CBOR_MULTICODEC = typeof DAG_CBOR_MULTICODEC\n\nexport const RAW_MULTICODEC = 0x55 // raw binary codec used in DASL CIDs\nexport type RAW_MULTICODEC = typeof RAW_MULTICODEC\n\nexport const SHA256_MULTIHASH = sha256.code\nexport type SHA256_MULTIHASH = typeof SHA256_MULTIHASH\n\nexport type MultihashDigest<Code extends number = number> = {\n  code: Code\n  digest: Uint8Array\n  size: number\n  bytes: Uint8Array\n}\n\ndeclare module 'multiformats/cid' {\n  /**\n   * @deprecated use the {@link Cid} interface from `@atproto/lex-data`, and\n   * related helpers ({@link isCid}, {@link ifCid}, {@link asCid},\n   * {@link parseCid}, {@link decodeCid}), instead.\n   *\n   * This is marked as deprecated because we want to discourage direct usage of\n   * `multiformats/cid` in dependent packages, and instead have them rely on the\n   * {@link Cid} interface from `@atproto/lex-data`. The {@link CID} class from\n   * `multiformats` version <10 has compatibility issues with certain TypeScript\n   * configuration, which can lead to type errors in dependent packages.\n   *\n   * We are stuck with version 9 because `@atproto` packages did not drop\n   * CommonJS support yet, and multiformats version 10 only supports ES modules.\n   *\n   * In order to avoid compatibility issues, while preparing for future breaking\n   * changes (CID in multiformats v10+ has a slightly different interface), as\n   * we update or swap out `multiformats`, we provide our own stable {@link Cid}\n   * interface.\n   */\n  interface CID {}\n}\n\n// multiformats' CID class is not very portable because:\n//\n// - In dependent packages that use \"moduleResolution\" set to \"node16\",\n//   \"nodenext\" or \"bundler\", TypeScript fails to properly resolve the\n//   multiformats package when importing CID from @atproto/lex-data. This causes\n//   type errors in those packages. This is caused by the fact that the\n//   multiformats version <10 (which is the last version that supports CommonJS)\n//   uses \"exports\" field in package.json, which do not contain \"types\"\n//   entrypoints.\n//   https://www.npmjs.com/package/multiformats/v/9.9.0?activeTab=code\n// - By defining our own interface and helper functions, we can have more\n//   control over the public API exposed by this package.\n// - It allow us to have a stable interface in case we need to swap out, or\n//   eventually update multiformats (should we choose to drop CommonJS support)\n//   in the future.\n\n// @NOTE Even though it is not portable, we still re-export CID here so that\n// dependent packages where it can be used, have access to it (instead of\n// importing directly from \"multiformats\" or\"multiformats/cid\").\nexport { CID }\n\n/**\n * Interface for working with decoded CID string, compatible with\n * {@link CID} implementation.\n */\nexport interface Cid {\n  version: 0 | 1\n  code: number\n  multihash: MultihashDigest\n  bytes: Uint8Array\n  equals(other: unknown): boolean\n  toString(): string\n}\n\n/**\n * Represents the cid of raw binary data (like media blobs).\n * @see {@link https://atproto.com/specs/data-model#link-and-cid-formats ATproto Data Model - Link and CID Formats}\n */\nexport interface RawCid extends Cid {\n  version: 1\n  code: RAW_MULTICODEC\n}\n\nexport function isRawCid(cid: Cid): cid is RawCid {\n  return cid.version === 1 && cid.code === RAW_MULTICODEC\n}\n\n/**\n * Represents a DASL compliant CID.\n * @see {@link https://dasl.ing/cid.html DASL-CIDs}\n */\nexport interface DaslCid extends Cid {\n  version: 1\n  code: RAW_MULTICODEC | DAG_CBOR_MULTICODEC\n  multihash: MultihashDigest<SHA256_MULTIHASH>\n}\n\nexport function isDaslCid(cid: Cid): cid is DaslCid {\n  return (\n    cid.version === 1 &&\n    (cid.code === RAW_MULTICODEC || cid.code === DAG_CBOR_MULTICODEC) &&\n    cid.multihash.code === SHA256_MULTIHASH &&\n    cid.multihash.size === 32 // Should always be 32 bytes (256 bits) for SHA-256\n  )\n}\n\n/**\n * Represents the cid of ATProto DAG-CBOR data (like repository MST nodes).\n * @see {@link https://atproto.com/specs/data-model#link-and-cid-formats ATproto Data Model - Link and CID Formats}\n */\nexport interface CborCid extends DaslCid {\n  code: DAG_CBOR_MULTICODEC\n}\n\nexport function isCborCid(cid: Cid): cid is CborCid {\n  return cid.code === DAG_CBOR_MULTICODEC && isDaslCid(cid)\n}\n\nexport type CidCheckOptions = {\n  flavor?: 'raw' | 'cbor' | 'dasl'\n}\nexport type InferCheckedCid<TOptions> = TOptions extends { flavor: 'raw' }\n  ? RawCid\n  : TOptions extends { flavor: 'cbor' }\n    ? CborCid\n    : Cid\n\n/**\n * Coerces the input value to a Cid, or returns null if not possible.\n */\nexport function ifCid<TOptions extends CidCheckOptions>(\n  value: unknown,\n  options: TOptions,\n): InferCheckedCid<TOptions> | null\nexport function ifCid(value: unknown, options?: CidCheckOptions): Cid | null\nexport function ifCid(value: unknown, options?: CidCheckOptions): Cid | null {\n  const cid = CID.asCID(value)\n  if (!cid) {\n    return null\n  }\n\n  switch (options?.flavor) {\n    case 'cbor':\n      return isCborCid(cid) ? cid : null\n    case 'raw':\n      return isRawCid(cid) ? cid : null\n    case 'dasl':\n      return isDaslCid(cid) ? cid : null\n    default:\n      return cid\n  }\n}\n\nexport function isCid<TOptions extends CidCheckOptions>(\n  value: unknown,\n  options: TOptions,\n): value is InferCheckedCid<TOptions>\nexport function isCid(value: unknown, options?: CidCheckOptions): value is Cid\nexport function isCid(value: unknown, options?: CidCheckOptions): value is Cid {\n  return ifCid(value, options) !== null\n}\n\n/**\n * Coerces the input value to a Cid, or throws if not possible.\n */\nexport function asCid<TOptions extends CidCheckOptions>(\n  value: unknown,\n  options: TOptions,\n): InferCheckedCid<TOptions>\nexport function asCid(value: unknown, options?: CidCheckOptions): Cid\nexport function asCid(value: unknown, options?: CidCheckOptions): Cid {\n  const cid = ifCid(value, options)\n  if (cid) return cid\n  throw new Error('Not a valid CID')\n}\n\n/**\n * Parses a CID string into a Cid object.\n *\n * @throws if the input is not a valid CID string.\n */\nexport function parseCid<TOptions extends CidCheckOptions>(\n  input: string,\n  options: TOptions,\n): InferCheckedCid<TOptions>\nexport function parseCid(input: string, options?: CidCheckOptions): Cid\nexport function parseCid(input: string, options?: CidCheckOptions): Cid {\n  const cid = CID.parse(input)\n  return asCid(cid, options)\n}\n\n/**\n * Decodes a CID from its binary representation.\n *\n * @see {@link https://dasl.ing/cid.html DASL-CIDs}\n * @throws if the input do not represent a valid DASL {@link Cid}\n */\nexport function decodeCid<TOptions extends CidCheckOptions>(\n  cidBytes: Uint8Array,\n  options: TOptions,\n): InferCheckedCid<TOptions>\nexport function decodeCid(cidBytes: Uint8Array, options?: CidCheckOptions): Cid\nexport function decodeCid(\n  cidBytes: Uint8Array,\n  options?: CidCheckOptions,\n): Cid {\n  const cid = CID.decode(cidBytes)\n  return asCid(cid, options)\n}\n\nexport function validateCidString(\n  input: string,\n  options?: CidCheckOptions,\n): boolean {\n  return parseCidString(input, options)?.toString() === input\n}\n\nexport function parseCidString<TOptions extends CidCheckOptions>(\n  input: string,\n  options: TOptions,\n): InferCheckedCid<TOptions> | undefined\nexport function parseCidString(\n  input: string,\n  options?: CidCheckOptions,\n): Cid | undefined\nexport function parseCidString(\n  input: string,\n  options?: CidCheckOptions,\n): Cid | undefined {\n  try {\n    return parseCid(input, options)\n  } catch {\n    return undefined\n  }\n}\n\nexport function ensureValidCidString(\n  input: string,\n  options?: CidCheckOptions,\n): void {\n  if (!validateCidString(input, options)) {\n    throw new Error(`Invalid CID string`)\n  }\n}\n\n/**\n * Verifies whether the multihash of a given {@link cid} matches the hash of the provided {@link bytes}.\n * @params cid The CID to match against the bytes.\n * @params bytes The bytes to verify.\n * @returns true if the CID matches the bytes, false otherwise.\n */\nexport async function isCidForBytes(\n  cid: Cid,\n  bytes: Uint8Array,\n): Promise<boolean> {\n  if (cid.multihash.code === sha256.code) {\n    const digest = await sha256.digest(bytes)\n    return digestEquals(cid.multihash, digest)\n  }\n\n  if (cid.multihash.code === sha512.code) {\n    const digest = await sha512.digest(bytes)\n    return digestEquals(cid.multihash, digest)\n  }\n\n  // Don't know how to verify other multihash codes\n  throw new Error('Unsupported CID multihash')\n}\n\nexport async function cidForCbor(bytes: Uint8Array): Promise<CborCid> {\n  const digest = await sha256.digest(bytes)\n  return CID.createV1(DAG_CBOR_MULTICODEC, digest) as CborCid\n}\n\nexport async function cidForRawBytes(bytes: Uint8Array): Promise<RawCid> {\n  const digest = await sha256.digest(bytes)\n  return CID.createV1(RAW_MULTICODEC, digest) as RawCid\n}\n\nexport function cidForRawHash(hash: Uint8Array): RawCid {\n  // Fool-proofing\n  if (hash.length !== 32) {\n    throw new Error(`Invalid SHA-256 hash length: ${hash.length}`)\n  }\n  const digest = createDigest(sha256.code, hash)\n  return CID.createV1(RAW_MULTICODEC, digest) as RawCid\n}\n"]}